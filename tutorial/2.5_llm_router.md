# 2.5 Provider Routing (Dynamic Selection)

### Introduction
The "One Size Fits All" model is dead in production. Effective AI systems use small, fast models for easy tasks and large, smart models for complex ones. Routing is the "brain" that makes this choice.

### Objective
Learn how to build a "Routing Chain" that analyzes user intent and picks the best execution path.

### Concept
Routing is a **Logical Fork** in your pipeline:
1. **Classifier:** A small model determines the "category" of the input.
2. **Router:** A mapping that sends the input to the specific chain for that category.
3. **Execution:** Only the chosen path is run, saving time and tokens.

### Example
```python
from langchain_core.runnables import RunnableBranch

# Define the paths
coding_chain = prompt_code | llm_complex | parser
chat_chain = prompt_general | llm_fast | parser

# The Router logic
branch = RunnableBranch(
    (lambda x: "code" in x["topic"].lower(), coding_chain),
    chat_chain # Default path
)

full_pipeline = {"topic": intent_extractor} | branch
```

### 2 Use Cases
1. **Technical vs. General Support:** Routing hardware-specific error codes to a deep technical RAG, while general "How do I return a product?" goes to a standard FAQ chain.
2. **Language-Specific Pipelines:** Routing Spanish queries to a Spanish-indexed vector store and English queries to an English one.

### Real-World RAG & Agentic Context
In **Real-World RAG**, routing is the key to **"Multi-Index RAG"**. You might have one index for "Product Manuals" and another for "Legal Contracts". A router ensures the LLM doesn't look for a warranty in the legal section, improving search accuracy and reducing noise.
In **Agentic Systems**, routing IS **"Agent Delegation"**. In a multi-agent system (like LangGraph), a "Supervisory Agent" routes tasks to specialized "Worker Agents" (e.g., a "Coder Agent" or a "Researcher Agent"). This is the pinnacle of modern AI architectureâ€”specialization over generalization.

### Did you know?
Routing can be done without an LLM! If you have a list of keywords or a simple regex, you can route using standard Python functions injected into an LCEL chain with `RunnableLambda`. This is faster and 100% free.
