# 3.5 Agentic Patterns (Decision-Making)

### Introduction
A "Chain" is a train on a track—it goes from A to B every time. An "Agent" is a driver with a map—it decides which path to take based on the road conditions. This is the transition from "automation" to "autonomy".

### Objective
Learn the "ReAct" (Reason + Act) loop and understand how to transform custom Python functions into "Tools" that an LLM can control.

### Concept
1. **Tools:** Any Python function decorated so the LLM knows its purpose. 
2. **Agent Brain:** The LLM reasoning through a prompt that says: "You have these tools. How will you solve this user request?"
3. **Agent Executor:** The wrapper that handles the loop: `LLM calculates tool name -> System runs tool -> LLM reads result -> Repeat until solved`.

### Complete Implementation
Here is a self-contained agent that can use a custom Python tool to answer a question.

```python
from langchain_openai import ChatOpenAI
from langchain.agents import initialize_agent, Tool
from langchain.agents import AgentType

# 1. Define a custom Tool (a regular Python function)
def get_weather(location: str):
    return f"The weather in {location} is 25°C and sunny."

weather_tool = Tool(
    name="Weather_Tool",
    func=get_weather,
    description="Use this to get the weather for a specific location."
)

# 2. Setup the Agent Brain
# In production, ensure OPENAI_API_KEY is in your .env
llm = ChatOpenAI(temperature=0)

# 3. Initialize the Agent
agent = initialize_agent(
    tools=[weather_tool],
    llm=llm,
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True
)

# 4. Execution
# The LLM will decide to call Weather_Tool automatically
response = agent.run("What's the weather like in Paris?")
print(response)
```

### 2 Use Cases
1. **Autonomous Personal Assistant:** An agent that can check your calendar (Tool 1), look up flight prices (Tool 2), and send you a summary email (Tool 3).
2. **Dynamic Database Explorer:** Instead of a fixed dashboard, an agent that "decides" which SQL queries to run to explain why sales are down this month.

### Real-World RAG & Agentic Context
In **Real-World RAG**, agents solve the **"Query Ambiguity"** problem. A basic RAG system just searches. An *Agentic RAG* system says: "The user asked for 'the report'. Which report? I'll look at their recent file history first, then I'll search for the most relevant ones."
In **Agentic Systems**, tools are the **"Hands"** of the AI. Without tools, an LLM is just a brain in a jar. With tools, it can interact with your company's CRM, your GitHub repo, or your live database. The "Agentic Roadmap" for a business usually starts with simple RAG (Reading) and ends with Agents (Doing).

### Did you know?
The modern industry is moving toward **"LangGraph"**. While `initialize_agent` is great for simple tasks, LangGraph allows you to build complex agentic workflows with cycles, state, and "human-in-the-loop" approvals for sensitive actions.
